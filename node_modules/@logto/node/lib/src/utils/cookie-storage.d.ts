import { type PersistKey, type Storage } from '@logto/client';
import { type CookieSerializeOptions } from 'cookie';
import { PromiseQueue } from './promise-queue.js';
import { type SessionData } from './session.js';
type Nullable<T> = T | null;
export type CookieConfigBase = {
    cookieKey?: string;
    isSecure?: boolean;
    getCookie: (name: string) => Promise<string | undefined> | string | undefined;
    setCookie: (name: string, value: string, options: CookieSerializeOptions & {
        path: string;
    }) => Promise<void> | void;
};
export type SessionWrapper = {
    wrap: (data: SessionData, key: string) => Promise<string>;
    unwrap: (value: string, key: string) => Promise<SessionData>;
};
export type CookieConfig = CookieConfigBase & ({
    /** Required when using default session wrapper */
    encryptionKey: string;
    sessionWrapper?: never;
} | {
    /** Optional when custom sessionWrapper is provided */
    encryptionKey?: string;
    /** Custom session wrapper can be used to implement external storage solutions */
    sessionWrapper: SessionWrapper;
});
/**
 * A storage that persists data in cookies with encryption.
 */
export declare class CookieStorage implements Storage<PersistKey> {
    config: CookieConfig;
    protected get cookieOptions(): Readonly<{
        httpOnly: true;
        path: string;
        sameSite: "lax";
        secure: boolean;
        maxAge: number;
    }>;
    protected get cookieKey(): string;
    get data(): SessionData;
    protected sessionData: SessionData;
    protected saveQueue: PromiseQueue;
    /**
     * Handles the wrapping and unwrapping of session data.
     * Can be provided via config or defaults to using wrapSession/unwrapSession functions.
     * Users can implement custom storage solutions by providing their own sessionWrapper.
     */
    protected sessionWrapper: SessionWrapper;
    constructor(config: CookieConfig);
    init(): Promise<void>;
    getItem(key: PersistKey): Promise<Nullable<string>>;
    setItem(key: PersistKey, value: string): Promise<void>;
    removeItem(key: PersistKey): Promise<void>;
    destroy(): Promise<void>;
    protected save(): Promise<void>;
    protected write(data?: SessionData): Promise<void>;
}
export {};
